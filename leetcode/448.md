# 题目:
    给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 )的整型数组，数组中的元素一些出现了两次，另一些只出现一次。

    找到所有在 [1, n] 范围之间没有出现在数组中的数字。

    您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

# 示例:
    > 输入: [4,3,2,7,8,2,3,1]

    > 输出: [5,6]

# 思路:
    1. hash算法 需要借助额外的储存空间
    2. 排序最低是O(n*lgn)
    3. "数组中的元素**一些**出现了两次" 累加的方式不可取
    注意到字母n，字母n不仅是数组元素的最大值,也是数组的大小(非常适用hash算法,但又不能使用额外的储存空间)
    → 想到"原地修改".
    再者:注意数组元素的取值范围最小为1？不能为负数可以理解(hash 映射时并不好操作)但为什么不能是0？.
    
    这类问题的关键是标记出读取过的元素！！下面两种方法采用了两种标记方法均为间接标记。
    
    官方解法1: 
    遍历输入数组的每个元素一次。
    1. 我们将把 |nums[i]|-1 索引位置的元素标记为负数。即nums[ |nums[i]| − 1 ] × −1.
    2. 然后遍历数组，若当前数组元素 nums[i] 为负数，说明我们在数组中存在数字 i+1.

    解法2：
    1. 将数组元素对应为索引的位置加n
    2. 遍历加n后的数组，若数组元素值小于等于n，则说明数组下标值不存在，即消失的数字.

    i=0:4   3   2   7   8   2   3   1
    i=1:            15
    i=2:        10
    i=3:    11                  
    i=4:                        11
    i=5:                            9
    i=6:    19
    i=7:        18
    i=8:12            
 

# 解答:
```c
int* findDisappearedNumbers(int* nums, int numsSize, int* returnSize){
    
    for(int i=0; i<numsSize ; i++ ){
        int j = nums[i]>0?nums[i]:-nums[i];
        if( nums[j-1]>0 ){
            nums[ j-1] = -1 * nums[j-1];
        }//else{ continue;}
    }
    int j =0;
    for(int i=0; i< numsSize; i++ ){
        if( nums[i]>0 ){
            nums[j] = i+1 ;
            j++;
        }
    }
    *returnSize= j;
    return nums;
}
```
