# C++内存组织模块

C++的虚拟内存空间主要分为以下的5个区域：
|栈|函数内的局部变量的存储单元都会在栈上创建, 函数执行结束时这些存储单元会被自动释放|
|:-:|:-|
|堆|也称为动态内存. 程序在运行的时候用malloc申请任意大小的内存|
|自由储存区|程序在运行时候利用new申请的内存空间.|
|全局/静态存储区|存储全局变量和静态变量, 处于该内存的变量在程序的整个运行期间都一直存在.|
|常量储存区|存储常量字符串, 程序结束后由系统释放|

## 自由存储区和堆的区别
从技术上来说, 堆(heap)是 C 语言和操作系统的术语, 它是操作系统所维护的一块特殊内存, 提供了动态分配的功能, 当运行程序调用malloc()时就会从堆中分配内存, 之后会调用free()将内存归还. 而自由存储区是 C++ 中通过new和delete动态分配和释放对象的 抽象概念, 通过new来申请的内存区域成为自由存储区. **实际上, 基本所有的 C++ 编译器都默认使用堆来实现自由存储区.** 也就是说, 缺省的 全局运算符 new和delete大多会通过malloc和free来实现, 这时候我们说new申请的内存在自由存储区上或者在堆中都是正确的. 但是程序员可以通过重载new和delete运算符, 来改用其他内存实现自由存储区, 这时候自由存储区就区别于堆了. 我们所需要记住的是: 堆是操作系统维护的一块特殊内存, 而自由存储区是 C++ 中通过new和delete动态分配和释放对象的抽象概念. 二者并不完全等价.

# 指针类型与引用类型的疑惑.
```C++
// 运行软件:VS
#include <stdio.h>
#include <string>

int main() {
    int a;
    int* p;
    p = &a;
    std::string s = "hello!!";
    std::string& m = s;
    //使用c语言的printf函数打印出各个变量的地址
    printf("a的地址:%x\n",&a);
    printf("p的地址:%x\n",&p);
    printf("p的值:%x\n",p);
    printf("s的地址:%x\n",&s);
    printf("m的地址:%x\n",&m);
    printf("m的值:%x",m);
    /*
    * a的地址:72cff684
    * p的地址:72cff6a8
    * p的值:72cff684  // p中储存的变量a的地址
    * s的地址72cff6c8 // 与p相差
    * m的地址72cff6c8  // string &m 与 string s的地址相同?? &m与&s是等价的，与C语言不同，这里m其实是s的别名.
    * 更详细的查看内存后，你会发现 s和m都储存着0x1ebc3153020这个地址(这个位置储存的是_Mycont的地址).即两个实际上都指向着同一块区域，这个区域又指向另一个相同的区域.
    * m的值72cff710   
    * */ 
}
```

## delete []p与 delete p
当我们书写如下代码时，我们会很快的
```c++
....
int p = new int
...
```